:source-highlighter: Highlight.js
== Networking

=== Arten von Netzwerke

:hexadecimal: link:basics.adoc[Hex in Dezimal]

=== Stream sockets (tcp)
Zuverlässige Sockets bei denen es darauf ankommt, dass die Daten ankommen und auch in der Richtigen reinfolge ankommen.

Anwendungen: +

* telnet
* ssh
* http

All diese bauen auf eine Zuverlässige verbindung auf, welche in richtiger Reihenfolge sein muss.

=== Datagram sockets (udp) - connectionless

Daten in eine Packet kommen ohne fehler an, jedoch können die Packets nicht in richtiger Reihenfolge und nicht alle ankommen. So werden einfach nur daten an eine ip addresse geschickt ohne eine Richtige Verbindung offen zu halten. Desswegen auch connectionless.

* tftp
* dhpcd

Diese Protokolle benutzen datagram sockets. Auch wenn diese ebenfalls genaue daten brauchen haben diese jewals ihr eigenes Protokoll um nicht erhaltene daten zu ermitteln und erneeut zu bekommen +

Für spiele ist solch eine Daten zuverlässigkeit egal wesswegen man oft sowas einfach ignoriert. +

Warum sollte man also eine unzuverlässigere verbindung nutzen ? Geschwindigkeit. Datagram sockets sind viel schneller. Für sowas wie die Übermittlung von Nachichten ist ein zuverlässige socket verbindung (tcp) viel besser, aber in einem Spiel wo mehrere male die Position eines Spielers gesendet werden muss ist es nicht Problematisch wenn packets nicht ankommen. Desswegen wird hier dann eine schnellere aber unzuverlässigere Verbindung genutzt. +

=== Zusammenfasung
Welche gibt es ?

* Stream sockets(tcp)
** Zuverlässig
** Langsam
* Datagram sockets(udp)
** Unzuverlässig
** Schnell +


'''

== OSI-Modell - Netzwerk theorie
ügendwann mal hier was reinschreiben

'''

== Ip Adressen, structs und Data Munging

=== Ipv4 und Ipv6
Früher ipv4. Heute eher ipv6 wegen zu wenige Ip adressen


ipv6 ist in hexadecimal form. {hexadecimal}

ipv6 addressen mit nullen können komprimiert werden:

2001:0db8:c9d2:0012:0000:0000:0000:0051 +
2001:db8:c9d2:12::51 +
Auch ipv4 addressen können einfach als ipv6 adressen dargestellt werden: +
192.168.111.50 +
::ffff:192.168.111.50

=== Subnetze
Eine netmask gibt vor wie eine Ip addrese im Netzwerk aufgebaut wird. +
Ist die Ip = 192.168.111.123 und die Netzmaske = 255.255.255.0 so wäre die Ip adresse immer 192.168.111.xxx wobei die letzten drei den Host im Netzwerk beschreiben 
'''

=== Port nummern
Ports dienen dazu eine Netzwerk verbindung zu einer bestimmten Anwendung zu zuordnen. Beispielsweise wäre die Ip dann die Straße zu einem Hochhaus und der Port die Nummer für die Wohnung. +
Wenn man zum Beispiel ein Mail und web service hat muss man die einkommenden Daten auch irgendwie zuordnen können. +

Da es viele standard Protokolle gibt, gibt es ebenso standart port nummern die für bestimmte System anwendungen genutzt werden. z.b ssh=22, smtp=25 https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml[List of Ports]

=== Byte order
Es gibt zwei wege eine zwei Byte hex nummer zu Speichern: b34f erst b3 dann 4f. Dies nennt man Big-Endian also in der Richtigen reihenfolge abspeichern. Manche computer (Intel) speichert die Daten andersrum also nach dem Little-Endian system. +
 +
Der computer speichert nummern in Host Byte Order, wobei wieder zwischen Little-Endian und Big-Endian unterschieden wird. Desswegen muss sichergestellt werden das, wenn man packete erstellt, diese auch in der Richtigen order sind. +
 +
Um das Problem zu lösen wird einfach angenommen das die Host byte order niemals richtig ist und man einfach eine Funktion aufruft um diese in die Richtige Netwrok Byte order bringt. + 
 +
Es gibt zwei Arten die Konvertiert werden können. Einmal ein short also zwei byte oder ein long also view Byte. Dementrsprechend heißt dann auch die Funktion also h für host dann to dann n for network und s for short also h-to-n-s
[source,c]
----
htons() // host to netowrk short
htonl() // host to network long
ntohs() // network to host short
ntohl() // network to host long
----

=== structs
link:basics.adoc[Struct] + 
Der File descriptor hat einfach den Typ int
//#TODO: erklärung hier einfügen
[,c]
----
struct addrinfo {
    int              ai_flags;     // AI_PASSIVE, AI_CANONNAME, etc.
    int              ai_family;    // AF_INET, AF_INET6, AF_UNSPEC
    int              ai_socktype;  // SOCK_STREAM, SOCK_DGRAM
    int              ai_protocol;  // use 0 for "any"
    size_t           ai_addrlen;   // size of ai_addr in bytes
    struct sockaddr *ai_addr;      // struct sockaddr_in or _in6
    char            *ai_canonname; // full canonical hostname

    struct addrinfo *ai_next;      // linked list, next node
};
----
Diese Struct wird dann mithilfe von _getaddrinfo()_ gefühllt. Desswegen brauch man das meistens gar nicht selber zu erstellen. Trozdem ist es wichtig die einzelne Bestandteile zu verstehen, da man diese lesen und eventuell auch selber ändern muss.
//#TODO: nochmal überdenken
 +
 +
Man kann mit _ai_family_ bestimmen of es sich um _ipv4 ipv6_ handelt oder mit _AF_UNSPEC_ es sich um beides handeln könnte. +
 +
Wie man sieht ist _ai_addr_ in _addrinfo_ ein pointer zu einem _struct sockaddr_. Hier fängt es dann an ein bisschen komplizierter zu werden. +
+
Der struct _sockaddr_ entählt die Information der socket addresse. +
Um besser mit _struct sockaddr_ umzgehen wurde das struct _sockaddr_in_. Dabei steht in für internet. Man kann immer _sockaddr_in in _sockaddr_ umwandeln und anders rum. Auch wenn später von connect ein sock_addr gefordert wird kann man einfach _sockaddr_in_ zu einem _sockaddr_in_ casten: _(struct sockaddr*)sockaddr_in_. +
 +
[source,c]
----
// (IPv4 only--see struct sockaddr_in6 for IPv6)

struct sockaddr_in {
    short int          sin_family;  // Address family, AF_INET
    unsigned short int sin_port;    // Port number
    struct in_addr     sin_addr;    // Internet address
    unsigned char      sin_zero[8]; // Same size as struct sockaddr
};
----
//#TODO: richtig übersetzen:
This structure makes it easy to reference elements of the socket address. Note that sin_zero (which is included to pad the structure to the length of a struct sockaddr) should be set to all zeros with the function memset(). Also, notice that sin_family corresponds to sa_family in a struct sockaddr and should be set to “AF_INET”. Finally, the sin_port must be in Network Byte Order (by using htons()!) +
 +
Das gleiche gibt es auch für ipv6:
[source,c]
----
// (IPv6 only--see struct sockaddr_in and struct in_addr for IPv4)

struct sockaddr_in6 {
    u_int16_t       sin6_family;   // address family, AF_INET6
    u_int16_t       sin6_port;     // port number, Network Byte Order
    u_int32_t       sin6_flowinfo; // IPv6 flow information
    struct in6_addr sin6_addr;     // IPv6 address
    u_int32_t       sin6_scope_id; // Scope ID
};

struct in6_addr {
    unsigned char   s6_addr[16];   // IPv6 address
};
----
//#TODO:ipv6 erklären
Ipv6 wird erstmal ausgelassen
//#TODO: das hier übersetzen und erklären
Last but not least, here is another simple structure, struct sockaddr_storage that is designed to be large enough to hold both IPv4 and IPv6 structures. See, for some calls, sometimes you don’t know in advance if it’s going to fill out your struct sockaddr with an IPv4 or IPv6 address. So you pass in this parallel structure, very similar to struct sockaddr except larger, and then cast it to the type you need:

struct sockaddr_storage {
    sa_family_t  ss_family;     // address family

    // all this is padding, implementation specific, ignore it:
    char      __ss_pad1[_SS_PAD1SIZE];
    int64_t   __ss_align;
    char      __ss_pad2[_SS_PAD2SIZE];
};

What’s important is that you can see the address family in the ss_family field—check this to see if it’s AF_INET or AF_INET6 (for IPv4 or IPv6). Then you can cast it to a struct sockaddr_in or struct sockaddr_in6 if you wanna. +

=== Ip adressen und part deux
Um eine Ip adresse umzuwandeln brauch man lediglich die funktion _inet_pton()_, welche eine Ip addresse in ein _struct in_addr_ oder ein _struct in6_addr_ umwandelt:
[source,c]
----
struct sockaddr_in sa;  //Ipv4
struct sockaddr_in sa6; //Ipv6

inet_pton(AF_INET, "10.12.110.57", &(sa.sin_addr)); // IPv4
inet_pton(AF_INET6, "2001:db8:63b3:1::3490", &(sa6.sin6_addr)); // IPv6
----

 +
:hide-uri-scheme:
Quelle: https://beej.us/guide/bgnet/html//index.html#what-is-a-socket




